<!doctype html>
<html lang="it">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebApp</title>

  <!-- Leaflet CSS/JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script src="https://unpkg.com/georaster"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>

  <link rel="stylesheet" href="static/css/index.css" />
  <link rel="stylesheet" href="static/css/chat.css" />
</head>

<body>
  <div id="map"></div>
  <div id="legend" class="legend" style="display:none"></div>

  <!-- CHAT flottante (come originale) -->
  <section class="chat" aria-label="Chat con agente AI">
    <header>
      <h3>Assistente AI</h3>
      <small>semplice & minimale</small>
    </header>
    <div id="chatMsgs" role="log" aria-live="polite"></div>
    <div class="inputRow">
      <textarea id="chatInput" placeholder="Scrivi un messaggio… (Invio per inviare, Shift+Invio per a capo)"></textarea>
      <button class="sendBtn" id="sendBtn">Invia</button>
    </div>
  </section>

  <script>

    function s3uri_to_https(s3_uri) {
      return s3_uri.replace('s3://', 'https://s3.us-east-1.amazonaws.com/')
    }
    // DOC: Base map
    const map = L.map("map", { preferCanvas: true }).setView([41.9, 12.5], 6); // Italia come default
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);

    // TEST: Url S3 (DEMO)
    const RASTER_URL = "https://s3.us-east-1.amazonaws.com/saferplaces.co/SaferPlaces-Agent/dev/various/output_cog.tif";   // COG GeoTIFF
    const VECTOR_URL = "https://s3.us-east-1.amazonaws.com/saferplaces.co/Directed/process_out/SaferBuildingsService/WD_custom_rim2d_sqamrly__flooded_buildings.geojson"; // GeoJSON

    // === 3) Aggiungi vettoriale GeoJSON da S3 ===
    // fetch(VECTOR_URL)
    //   .then(r => r.json())
    //   .then(data => {
    //     const vg = L.vectorGrid.slicer(data, {
    //       rendererFactory: L.canvas.tile,
    //       maxZoom: 19,
    //       interactive: true,
    //       // parametri di semplificazione (più alto = più veloce, meno preciso)
    //       tolerance: 3,       // default 3; alza a 5–8 per geometrie complesse
    //       extent: 4096,       // risoluzione interna
    //       indexMaxZoom: 5,    // livello max per indicizzazione
    //       indexMaxPoints: 100000 // batch di indicizzazione
    //       ,
    //       vectorTileLayerStyles: {
    //         sliced: f => {
    //           // stile unico per tutte le feature (nome layer = 'sliced')
    //           if (f.type === 1) return { radius: 3, color: "#0061ff", weight: 1, fillOpacity: 0.7 };
    //           return { color: "#0061ff", weight: 1, fillOpacity: 0.2 };
    //         }
    //       }
    //     })
    //       .on('click', e => {
    //         // popup minimale con prime proprietà
    //         const props = e.layer.properties || {};
    //         const rows = Object.entries(props).slice(0, 10)
    //           .map(([k, v]) => `<tr><th>${k}</th><td>${v}</td></tr>`).join("");
    //         L.popup().setLatLng(e.latlng).setContent(`<table>${rows}</table>`).openOn(map);
    //       })
    //       .addTo(map);
    //   });

    // === 4) Aggiungi raster COG GeoTIFF da S3 ===
    // Nota: assicura CORS sul bucket e che il TIFF sia un COG con overview.
    // (async () => {
    //   try {
    //     const response = await fetch(RASTER_URL, { headers: { "Range": "bytes=0-" } });
    //     if (!response.ok) throw new Error("Impossibile caricare GeoTIFF: " + response.status);
    //     const arrayBuffer = await response.arrayBuffer();

    //     const georaster = await parseGeoraster(arrayBuffer);
    //     // georaster.nodata, georaster.mins/maxs, georaster.pixelHeight etc. disponibili qui

    //     // Funzione colori semplice (da blu a rosso) usando min/max stimati
    //     const min = (georaster.mins && georaster.mins[0] != null) ? georaster.mins[0] : 0;
    //     const max = (georaster.maxs && georaster.maxs[0] != null) ? georaster.maxs[0] : 1;
    //     const nodata = Array.isArray(georaster.noDataValue) ? georaster.noDataValue[0] : georaster.noDataValue;

    //     function lerp(a, b, t) { return a + (b - a) * t; }
    //     function valueToColor(v) {
    //       if (v == null || Number.isNaN(v)) return null;
    //       if (nodata != null && v === nodata) return null;
    //       const t = Math.max(0, Math.min(1, (v - min) / (max - min || 1)));
    //       // gradiente blu(0,0,255) -> rosso(255,0,0)
    //       const r = Math.round(lerp(0, 255, t));
    //       const g = 0;
    //       const b = Math.round(lerp(255, 0, t));
    //       return `rgba(${r},${g},${b},0.7)`;
    //     }

    //     const rasterLayer = new GeoRasterLayer({
    //       georaster,
    //       opacity: 0.7,
    //       pixelValuesToColorFn: values => valueToColor(values[0]),
    //       resolution: 256 // più alto = più veloce (meno dettagli), regola se serve
    //     });

    //     rasterLayer.addTo(map);

    //     // Prova a fare fit sui bounds del raster (se il vettoriale non ha già fatto fit)
    //     try { map.fitBounds(rasterLayer.getBounds(), { padding: [20, 20] }); } catch (e) { }

    //     // Piccola legenda dinamica
    //     const legend = document.getElementById("legend");
    //     legend.style.display = "block";
    //     legend.innerHTML = `
    //       <div style="margin-bottom:6px;font-weight:600">Raster (valori)</div>
    //       <div style="display:flex;align-items:center;gap:8px">
    //         <span>${min.toFixed(2)}</span>
    //         <div style="height:10px;width:160px;background:linear-gradient(to right, #0000ff, #ff0000);border-radius:6px;"></div>
    //         <span>${max.toFixed(2)}</span>
    //       </div>
    //     `;
    //   } catch (err) {
    //     console.error(err);
    //     alert("Errore nel caricamento del raster COG. Vedi console per dettagli.");
    //   }
    // })();


    function addVectorLayer(src) {
      fetch(src)
        .then(r => r.json())
        .then(data => {
          const vg = L.vectorGrid.slicer(data, {
            rendererFactory: L.canvas.tile,
            maxZoom: 19,
            interactive: true,
            // parametri di semplificazione (più alto = più veloce, meno preciso)
            tolerance: 3,       // default 3; alza a 5–8 per geometrie complesse
            extent: 4096,       // risoluzione interna
            indexMaxZoom: 5,    // livello max per indicizzazione
            indexMaxPoints: 100000 // batch di indicizzazione
            ,
            vectorTileLayerStyles: {
              sliced: f => {
                // stile unico per tutte le feature (nome layer = 'sliced')
                if (f.type === 1) return { radius: 3, color: "#0061ff", weight: 1, fillOpacity: 0.7 };
                return { color: "#0061ff", weight: 1, fillOpacity: 0.2 };
              }
            }
          })
            .on('click', e => {
              // popup minimale con prime proprietà
              const props = e.layer.properties || {};
              const rows = Object.entries(props).slice(0, 10)
                .map(([k, v]) => `<tr><th>${k}</th><td>${v}</td></tr>`).join("");
              L.popup().setLatLng(e.latlng).setContent(`<table>${rows}</table>`).openOn(map);
            })
            .addTo(map);
        });
    }

    async function addRasterLayer(src) {
      const response = await fetch(RASTER_URL, { headers: { "Range": "bytes=0-" } });
      if (!response.ok) throw new Error("Impossibile caricare GeoTIFF: " + response.status);
      const arrayBuffer = await response.arrayBuffer();

      const georaster = await parseGeoraster(arrayBuffer);
      // georaster.nodata, georaster.mins/maxs, georaster.pixelHeight etc. disponibili qui

      // Funzione colori semplice (da blu a rosso) usando min/max stimati
      const min = (georaster.mins && georaster.mins[0] != null) ? georaster.mins[0] : 0;
      const max = (georaster.maxs && georaster.maxs[0] != null) ? georaster.maxs[0] : 1;
      const nodata = Array.isArray(georaster.noDataValue) ? georaster.noDataValue[0] : georaster.noDataValue;

      function lerp(a, b, t) { return a + (b - a) * t; }
      function valueToColor(v) {
        if (v == null || Number.isNaN(v)) return null;
        if (nodata != null && v === nodata) return null;
        const t = Math.max(0, Math.min(1, (v - min) / (max - min || 1)));
        // gradiente blu(0,0,255) -> rosso(255,0,0)
        const r = Math.round(lerp(0, 255, t));
        const g = 0;
        const b = Math.round(lerp(255, 0, t));
        return `rgba(${r},${g},${b},0.7)`;
      }

      const rasterLayer = new GeoRasterLayer({
        georaster,
        opacity: 0.7,
        pixelValuesToColorFn: values => valueToColor(values[0]),
        resolution: 256 // più alto = più veloce (meno dettagli), regola se serve
      });

      rasterLayer.addTo(map);

      // Prova a fare fit sui bounds del raster (se il vettoriale non ha già fatto fit)
      try { map.fitBounds(rasterLayer.getBounds(), { padding: [20, 20] }); } catch (e) { }

      // Piccola legenda dinamica
      const legend = document.getElementById("legend");
      legend.style.display = "block";
      legend.innerHTML = `
        <div style="margin-bottom:6px;font-weight:600">Raster (valori)</div>
        <div style="display:flex;align-items:center;gap:8px">
          <span>${min.toFixed(2)}</span>
          <div style="height:10px;width:160px;background:linear-gradient(to right, #0000ff, #ff0000);border-radius:6px;"></div>
          <span>${max.toFixed(2)}</span>
        </div>
      `;
    }



    function handleMapActions(action) {
      debugger
      switch (action.action) {
        case 'new_layer':   // TODO: Should check in a registry of layer if layer_data.src is already present before to add it
          layer_data = action.layer_data;
          if (layer_data.type === 'vector') {
            addVectorLayer(s3uri_to_https(layer_data.src));
          }
          else if (layer_data.type === 'raster') {
            addRasterLayer(s3uri_to_https(layer_data.src));
          }
      }
    }



    // ——— Chat UI minimale (come originale, mock) ———
    const chatMsgs = document.getElementById('chatMsgs');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    function appendMsg(role, text) {
      const div = document.createElement('div');
      div.className = 'msg ' + (role === 'user' ? 'user' : 'bot');
      div.textContent = text; chatMsgs.appendChild(div); chatMsgs.scrollTop = chatMsgs.scrollHeight;
    }
    function processAgentMsg(message) {
      let msg_type = message.kwargs.type
      let msg_content = message.kwargs.content
      switch (msg_type) {
        case 'ai':
          appendMsg('bot', msg_content);
          break;
        case 'tool':
          // load json from json string content
          content = JSON.parse(msg_content.replace(/'/g, '"'));
          if (content.map_actions) {
            content.map_actions.map(action => handleMapActions(action));
          }
          console.log("Tool message content:", content);
          break;
      }
    }

    async function handleSend() {
      const t = chatInput.value.trim(); if (!t) return; appendMsg('user', t); chatInput.value = '';
      fetch('/agent/prompt', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ prompt: t }) })
        .then(r => { if (!r.ok) throw new Error('Errore'); return r.json(); })
        .then(d => {
          (d.response_data || []).forEach(m => {
            console.log(m);
            processAgentMsg(m);

            // appendMsg('bot', m)
          });
        })
        .catch(() => appendMsg('bot', 'Si è verificato un errore.'));
    }
    sendBtn.onclick = handleSend;
    chatInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } });
  </script>
</body>

</html>